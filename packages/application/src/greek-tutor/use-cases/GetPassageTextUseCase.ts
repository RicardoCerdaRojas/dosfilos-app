import { IGreekTutorService, ISessionRepository, BiblicalPassage, IBibleVersionRepository } from '@dosfilos/domain';

/**
 * Use case: Get biblical passage in multiple versions
 * 
 * SOLID Principles Applied:
 * - Dependency Inversion: Depends on IBibleVersionRepository abstraction
 * - Single Responsibility: Orchestrates passage retrieval only
 * 
 * Architecture Optimization:
 * - Uses LOCAL Bible repository for Spanish/English text (instant, 100% accurate)
 * - Only asks AI for Greek + Transliteration + Tokenization
 * - Reduces AI token usage by ~50%
 * - Faster response times
 */
export class GetPassageTextUseCase {
    constructor(
        private greekTutorService: IGreekTutorService,
        private sessionRepository: ISessionRepository,
        private bibleRepository: IBibleVersionRepository // ← NEW: Injected via DI
    ) { }

    /**
     * Executes the use case with cache-first strategy
     * @param reference Bible reference (e.g., "Romanos 12:1-2" or "Romans 12:1-2")
     * @param fileSearchStoreId Optional Exegesis Library store ID
     * @param language Output language (default: Spanish)
     * @returns BiblicalPassage with all versions and tokenized words
     */
    async execute(
        reference: string,
        fileSearchStoreId?: string,
        language: string = 'Spanish'
    ): Promise<BiblicalPassage> {
        console.log('[GetPassageTextUseCase] Fetching passage:', reference);

        // NEW: Get Bible text from LOCAL repository (not AI!) FIRST
        // This ensures we always have the correct language text (e.g. RVR1960 for Spanish users)
        // even if we hit a cache that was originally created with English text.
        const bibleText = this.bibleRepository.getVerses(reference);
        if (!bibleText) {
            throw new Error(`Invalid Bible reference: ${reference}`);
        }
        console.log('[GetPassageTextUseCase] Retrieved verse from local Bible:', bibleText.substring(0, 50) + '...');

        // Phase 3D: Check cache first (global across users)
        // Pass language to ensure we check the correct localized cache (avoid thrashing)
        const cached = await this.sessionRepository.getCachedPassage(reference, language);
        if (cached) {
            // STRICT VALIDATION: Check if cached text lang
            // We do this by comparing the first ~20 chars. If they are totally different, it's likely a language mismatch.
            // (e.g. Cached: "Así que, hermanos..." vs Target: "I beseech you...")
            const cachedSample = (cached.rv60Text || '').substring(0, 20).toLowerCase().replace(/[^a-z]/g, '');
            const targetSample = (bibleText || '').substring(0, 20).toLowerCase().replace(/[^a-z]/g, '');

            // Simple validation: If first few letters match, we assume same language/version.
            // If mismatch (e.g. Spanish vs English), we invalidate cache.
            // We use length check to avoid empty string edge cases.
            const isMatch = cachedSample.length > 0 && targetSample.length > 0 && (
                cachedSample === targetSample ||
                targetSample.startsWith(cachedSample) ||
                cachedSample.startsWith(targetSample)
            );

            // DEEP VALIDATION: Check for "Frankenstein" cache (Consistent Text but Mismatched Words)
            // This happens if we blindly overwrote rv60Text in a previous session but didn't regenerate words.
            // We check if a sample of significant words actually exists in the text.
            let isConsistent = true;
            if (isMatch) {
                const sampleWords = cached.words
                    .filter(w => w.spanish && w.spanish.length > 3) // Filter for significant words (>3 chars)
                    .slice(0, 5); // Take first 5 significant words

                if (sampleWords.length > 0) {
                    const textLower = (bibleText || '').toLowerCase();
                    const matchingWords = sampleWords.filter(w => textLower.includes(w.spanish.toLowerCase()));
                    // If less than 50% of the sample words are found in the text, it's likely a language mismatch
                    isConsistent = (matchingWords.length / sampleWords.length) >= 0.5;
                }
            }

            if (isMatch && isConsistent) {
                console.log('[GetPassageTextUseCase] Using cached passage (Cache HIT + Valid Language)');
                // Overwrite cached text with fresh local text to ensure exact version precision
                cached.rv60Text = bibleText;
                return cached;
            } else {
                console.warn('[GetPassageTextUseCase] Cache HIT but Text Mismatch (Language diff?). Regenerating...');
                // Fall through to regeneration
            }
        }

        // Generate ONLY Greek + Transliteration + Tokenization with Gemini
        // Bible text is now passed TO the AI, not generated BY it
        console.log('[GetPassageTextUseCase] Generating Greek analysis with Gemini...');
        try {
            const passage = await this.greekTutorService.getPassageText(
                reference,
                fileSearchStoreId,
                language,
                bibleText // ← NEW: Pass local Bible text to AI
            );

            // Phase 3D: Cache for future use
            // Include language in cache key to separate translations
            await this.sessionRepository.cachePassage(passage, language);
            console.log('[GetPassageTextUseCase] Successfully cached passage for reuse');

            return passage;
        } catch (error) {
            console.error('[GetPassageTextUseCase] Error fetching passage:', error);
            throw new Error(`Failed to fetch passage ${reference}: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
}
